<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="" />
  <meta name="author" content="and contributors" />
   <title>Primeiros passos em Julia</title>  
  <link rel="shortcut icon" type="image/png" href="/modelagem_matematica/assets/images/favicon.png"/>
  <link rel="stylesheet" href="/modelagem_matematica/css/base.css"/>
  
    <link rel="stylesheet" href="/modelagem_matematica/css/base_showaside.css"/>
  
  <script src="/modelagem_matematica/libs/mousetrap/mousetrap.min.js"></script>

  
    <link rel="stylesheet" href="/modelagem_matematica/libs/highlight/github.min.css">
    <script src="/modelagem_matematica/libs/highlight/highlight.pack.js"></script>
    <script src="/modelagem_matematica/libs/highlight/julia.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre').forEach((el) => {
          hljs.highlightElement(el);
        });
      });
    </script>
  

  
    <link rel="stylesheet" href="/modelagem_matematica/libs/katex/katex.min.css">
  
</head>

<body>

  <div class="books-container">

  <aside class="books-menu">
  <input type="checkbox" id="menu">
  <label for="menu">☰</label>

  <div class="books-title">
    <a href="/modelagem_matematica/">Modelagem Matemática</a>
  </div>

  <br />

  <div class="books-subtitle">
    Notas de aula
  </div>

  <br />

  <div class="books-author">
    <a href="https://rmsrosa.github.io">Ricardo M. S. Rosa</a>
  </div>

  <div class="books-menu-content">
    <div class="menu-level-1">
    <li><a href="/modelagem_matematica/pages/intro">Introdução</a></li>
    </div>
    <div class="menu-level-1">
    <li>PARTE I</li>
    </div>
    <div class="menu-level-1">
    <li>1. Preliminares</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c01/0101-Aspectos_curso">1.1. Aspectos do curso</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c01/0102-Instalando_acessando_Julia">1.2. Instalando e acessando o Julia</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c01/0103-Primeiros_passos_Julia">1.3. Primeiros passos em Julia</a></li>
    </div>
    <div class="menu-level-1">
    <li>PARTE II</li>
    </div>
    <div class="menu-level-1">
    <li>2. Princípios de Modelagem Matemática</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c02/0201-Principios_basicos">2.1. Princípios básicos de modelagem</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c02/0202-Exemplos_tipos_modelagem">2.2. Exemplos de tipos de modelagem</a></li>
    </div>
    <div class="menu-level-1">
    <li>3. Análise Dimensional</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c03/0301-Quantidades_unidades_dimensoes">3.1. Quantidades, unidades e dimensões</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c03/0302-BuckinghamPi">3.2. Análise dimensional e o Teorema de Buckingham-Pi</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c03/0303-Unidades_Julia">3.3. Trabalhando com unidades e dimensões em Julia</a></li>
    </div>
    <div class="menu-level-1">
    <li>4. Ajuste de Parâmetros</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0401-Minimos_quadrados_ajuste">4.1. Mínimos quadrados e o ajuste de parâmetros</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0402-Modelos_redutiveis_linear_aplicacoes">4.2. Modelos redutíveis ao caso linear nos parâmetros e aplicações</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0403-Minimos_quadrados_nao_linear">4.3. Mínimos quadrados não-linear</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0404-Exemplos_ajuste_naolinear">4.4. Exemplos de ajuste não-linear de parâmetros</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0405-Ajuste_em_redes_neurais">4.5. Ajuste de parâmetros em modelos de redes neurais (WIP)</a></li>
    </div>
<div>


  
    <a href="https://github.com/rmsrosa/modelagem_matematica/tree/modmat2022p1"><img src="/modelagem_matematica/assets/images/GitHub-Mark-32px.png" alt="GitHub repo" width="18" style="margin:5px 5px" align="left"></a>

  

</aside>


  <div class="books-content">

    
      <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c01/0102-Instalando_acessando_Julia">1.2. Instalando e acessando o Julia <kbd>←</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c02/0201-Principios_basicos"><kbd>→</kbd> 2.1. Princípios básicos de modelagem</a>
</span>
    </p>
</div>
</br></br>

    

    
      <div class="badges">
<p>
<a href="https://nbviewer.org/urls/rmsrosa.github.io/modelagem_matematica/tree/modmat2021p1/generated/notebooks/jupytered/c01/0103-Primeiros_passos_Julia.ipynb"><img align="left" src="https://img.shields.io/badge/view%20in-nbviewer-orange" alt="View in NBViewer" title="View Jupyter notebook in NBViewer"></a>
<a href="https://mybinder.org/v2/gh/rmsrosa/modelagem_matematica/julia-env-for-binder-2022p1?urlpath=git-pull%3Frepo%3Dhttps://github.com/rmsrosa/modelagem_matematica/tree/modmat2022p1%26urlpath%3Dlab/tree%252Fmodelagem_matematica/generated/notebooks/jupytered/c01/0103-Primeiros_passos_Julia.ipynb%26branch%3Dgh-pages"><img align="left" src="https://mybinder.org/badge.svg" alt="Open in binder" title="Open in binder"></a>
<a href="/modelagem_matematica/generated/notebooks/jupytered/c01/0103-Primeiros_passos_Julia.ipynb"><img align="left" src="https://img.shields.io/badge/download-notebook-blue" alt="Download notebook" title="Download Jupyter notebook"></a>
<a href="https://github.com/rmsrosa/modelagem_matematica/tree/modmat2022p1/blob/main/_src/jupyter/c01/0103-Primeiros_passos_Julia.ipynb"><img align="left" src="https://img.shields.io/badge/view-source-lightblue" alt="View source" title="View source"></a>
</p>
</div></br>

    
<h1 id="get_title"><a href="#get_title" class="header-anchor">1.3. Primeiros passos em Julia</a></h1>
<p>Há várias fontes de informação sobre a linguagem Julia. Vejam, por exemplo, os links informados no início do caderno anterior. Em particular,</p>
<ul>
<li><p>Guias rápidos</p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/">Julia Documentation</a></p>
</li>
<li><p><a href="https://julia.quantecon.org/getting_started_julia/index.html">Getting Started with Julia &#40;QuantEcon&#41;</a></p>
</li>
<li><p><a href="https://juliadocs.github.io/Julia-Cheat-Sheet/br/">A via rápida para Julia 1.0</a></p>
</li>
<li><p><a href="https://cheatsheets.quantecon.org">MATLAB–Python–Julia cheatsheet &#40;QuantEcon&#41;</a></p>
</li>
<li><p><a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></p>
</li>
</ul>
</li>
<li><p>Mais detalhados</p>
<ul>
<li><p><a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">Think Julia: How to Think Like a Computer Scientist</a></p>
</li>
<li><p><a href="https://en.wikibooks.org/wiki/Introducing_Julia">Introducing Julia</a></p>
</li>
<li><p><a href="http://ucidatascienceinitiative.github.io/IntroToJulia/">A Deep Introduction to Julia for Data Science and Scientific Computing</a></p>
</li>
</ul>
</li>
</ul>
<p>Não pretendo reinventar a roda, aqui. Sugiro que vejam pelo menos uns dois links dos mencionados. Em particular, <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Mathematical-Operations-and-Elementary-Functions">Mathematical Operations and Elementary Functions</a>, da documentação. A documentação do Julia é muito boa&#33;</p>
<p>Se você está acostumado com python, por exemplo, veja <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-Python">Noteworthy differences from Python</a>.</p>
<p>Vou apenas fazer alguns comentários que considero relevantes.</p>
<h2 id="blocos_de_código"><a href="#blocos_de_código" class="header-anchor">Blocos de código</a></h2>
<p>Identar o código é extramemente recomendado, mas, contrariamente ao python, não é obrigatório. Por isso, é necessário concluir os blocos com <code>end</code>.</p>
<p>A vantagem disso é que é fácil copiar um código e rodar em outro ambiente, como no REPL, por exemplo, sem se preocupar com o processo de copiar e colar modificar a identação.</p>
<pre><code class="language-julia">for i &#61; 1:5
    println&#40;i&#41;
end</code></pre>
<pre><code class="language-julia">1
2
3
4
5</code></pre>
<h2 id="caracteres_unicode"><a href="#caracteres_unicode" class="header-anchor">Caracteres unicode</a></h2>
<p>Caracteres unicode podem, e costumam ser, usados como variáveis. Você pode obtê-los, <em>em células de código</em>, digitando o símbolo deles seguido de <code>&lt;tab&gt;</code>. Vários nomes são derivados da denominação deles em latex. Por exemplo, para obter \(\pi\) acima, basta digitar <code>\pi&lt;tab&gt;</code>.</p>
<p>Para uma lista completa dos caracteres unicodes obtidos completando com <code>&lt;tab&gt;</code>, veja <a href="https://docs.julialang.org/en/v1/manual/unicode-input/">Unicode Input</a>.</p>
<p>Subescritos e superescritos podem ser obtidos com <code>^\&#96; e</code>_&#96;, seguidos de <code>&lt;tab&gt;</code>. Por exemplo \(x_1\) é obtido com <code>x\_1&lt;tab&gt;</code>.</p>
<p>Outros &quot;adereços&quot; tambem podem ser obtidos com <code>&lt;tab&gt;</code>, por exemplo, \(\bar x\) é obtido com <code>x\bar&lt;tab&gt;</code> e \(\tilde x\), com <code>x\tilde&lt;bar&gt;</code>.</p>
<p>Aproveitando a questão da notação, a multiplicação entre um número e um símbolo <em>não precisa</em> usar o símbolo de multiplicação <code>*</code>.</p>
<p>Exemplos:</p>
<pre><code class="language-julia">ϵ &#61; 0.01
ξ &#61; 0:0.01:2π
η &#61; sin.&#40;ξ&#41;
ξ̄ &#61; ξ&#91;argmax&#40;η&#41;&#93;
println&#40;&quot;Máximo de ξ ↦ sin&#40;ξ&#41; em ξ̄ &#61; &#36;ξ̄.&quot;&#41;
error &#61; abs&#40;ξ̄ - π/2&#41; &lt; ϵ ? &quot;Dentro da margem de erro ϵ &#61; &#36;ϵ em relação ao valor esperado π/2.&quot; :
    &quot;Fora da margem de error ϵ &#61; &#36;ϵ em relação ao valor esperado π/2.&quot;
println&#40;error&#41;</code></pre>
<pre><code class="language-julia">Máximo de ξ ↦ sin&#40;ξ&#41; em ξ̄ &#61; 1.57.
Dentro da margem de erro ϵ &#61; 0.01 em relação ao valor esperado π/2.</code></pre>
<h2 id="broadcasting_e_o_operador_ponto"><a href="#broadcasting_e_o_operador_ponto" class="header-anchor">Broadcasting e o &quot;operador ponto&quot;</a></h2>
<p>O operador ponto aplica uma operação a cada elemento de um vetor ou matriz ou adiciona um escalar a cada componente de um vetor. O operador ponto está diretamente ligado ao operador de <em>broadcasting</em>. Veja mais sobre isso em <em>&#40;<a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#man-dot-operators">dot operators</a>&#41;</em> e <em><a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasting</a></em>. Por aqui, fiquemos com os seguintes exemplos.</p>
<pre><code class="language-julia">@show 2^2
@show &#91;1,2,3&#93;.^2
@show &#91;1 2; 3 4&#93;.^2
@show sin.&#40;&#91;0, π/4, π/2, π&#93;&#41;
@show 1 .&#43; &#91;1,2,3,4&#93;
nothing</code></pre>
<pre><code class="language-julia">2 ^ 2 &#61; 4
&#91;1, 2, 3&#93; .^ 2 &#61; &#91;1, 4, 9&#93;
&#91;1 2; 3 4&#93; .^ 2 &#61; &#91;1 4; 9 16&#93;
sin.&#40;&#91;0, π / 4, π / 2, π&#93;&#41; &#61; &#91;0.0, 0.7071067811865475, 1.0, 1.2246467991473
532e-16&#93;
1 .&#43; &#91;1, 2, 3, 4&#93; &#61; &#91;2, 3, 4, 5&#93;</code></pre>
<h2 id="atribuição_e_variáveis_mutáveis_e_imutáveis"><a href="#atribuição_e_variáveis_mutáveis_e_imutáveis" class="header-anchor">Atribuição e variáveis mutáveis e imutáveis</a></h2>
<p>Alguns objetos são mutáveis, enquanto que outros, não. Um objeto mutável pode ter os seus valores alterados. Já um objeto imutável, não, mas ele pode ser redefinido.</p>
<p>Isso pode ser visto explicitamente pelo seu ponteiro &#40;pelo menos em alguns casos&#41;.</p>
<h3 id="atribuição_de_vetores"><a href="#atribuição_de_vetores" class="header-anchor">Atribuição de vetores</a></h3>
<p>Por exemplo. Um vetor é imutável, mas os seu valores, não. Se mudarmos apenas o valor de um ou mais de seus elementos, ele continua apontando para o mesmo local na memória. Já se o redefinirmos, ele pode passar a apontar para outro lugar. Isso é visivelmente natural se pensarmos que, nesse processo, podemos acabar alterando o tamanho do vetor e, com isso, pode ser necessário mudá-lo de posição para que ele caiba na memória.</p>
<p>Essa mudança no apontamento quando redefinimos uma variavel imutável pode ou não acontecer. Ela não é obrigatória. Mas ela nunca é alterada quando o valor, mutável, de uma variável é alterado.</p>
<pre><code class="language-julia">a &#61; &#91;0, 1&#93; # definição inicial de &#96;a&#96;
@show pointer&#40;a&#41;
a &#61; &#91;2, 3&#93; # redefinindo &#96;a&#96; para um vetor de mesmo comprimento
@show pointer&#40;a&#41;
a &#61; &#91;4, 5, 6&#93; # redefindo &#96;a&#96; para um vetor de comprimento diferente
@show pointer&#40;a&#41;
a&#91;1&#93; &#61; 7 # modificando um elemento de &#96;a&#96;
@show pointer&#40;a&#41;
a&#91;1:3&#93; &#61; &#91;8,9,0&#93; # modificando todos os elementos de &#96;a&#96;
@show pointer&#40;a&#41;
nothing</code></pre>
<pre><code class="language-julia">pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162ac1530
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b77e20
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b78bd0
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b78bd0
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b78bd0</code></pre>
<h3 id="atribuição_de_strings"><a href="#atribuição_de_strings" class="header-anchor">Atribuição de strings</a></h3>
<p><em>Strings</em> também são imutáveis.</p>
<pre><code class="language-julia">s &#61; &quot;Equações diferenciais&quot;
@show pointer&#40;s&#41;
s &#61; &quot;Modelagem Matemática&quot;
@show pointer&#40;s&#41;
s &#61; replace&#40;s, &quot;Modelagem&quot; &#61;&gt; &quot;Modelos&quot;&#41;&#91;1:end-1&#93;*&quot;os&quot;
@show pointer&#40;s&#41;
@show s
nothing</code></pre>
<pre><code class="language-julia">pointer&#40;s&#41; &#61; Ptr&#123;UInt8&#125; @0x000000010a254a68
pointer&#40;s&#41; &#61; Ptr&#123;UInt8&#125; @0x000000010a254ab8
pointer&#40;s&#41; &#61; Ptr&#123;UInt8&#125; @0x000000010a254cc0
s &#61; &quot;Modelos Matemáticos&quot;</code></pre>
<h3 id="cuidados_com_a_atribuição_de_variáveis_imutáveis"><a href="#cuidados_com_a_atribuição_de_variáveis_imutáveis" class="header-anchor">Cuidados com a atribuição de variáveis imutáveis</a></h3>
<p>No caso de um objeto imutável mas com elementos mutáveis &#40;e.g. <em>arrays</em>, <em>dicts</em>, <em>sets</em>&#41;, é preciso termos cuidado quando tentamos copiá-lo.</p>
<p>A atribuição pura e simples não acarreta em uma cópia, ela faz com que o novo objeto faça referência ao mesmo objeto. Assim, se modificarmos os valores mutáveis do objeto original, o novo objeto sofrerá as mesmas mudanças.</p>
<p>No exemplo abaixo, observe que a redefinição da variável imutável <code>p1</code> não afetou <code>p2</code>, mas a mudança nos valores mutáveis de <code>p3</code> afetou <code>p4</code>.</p>
<p>Para evitar isso, é preciso usar <code>copy</code>. Nesse caso, vemos que <code>p5</code> não sofreu alteração.</p>
<pre><code class="language-julia">p1 &#61; &#91;10,20&#93;
p2 &#61; p1
p1 &#61; &#91;30,40&#93;
@show p1
@show p2
p3 &#61; &#91;50,60&#93;
p4 &#61; p3
p5 &#61; copy&#40;p3&#41;
p3&#91;1:2&#93; &#61; &#91;70,80&#93;
@show p3
@show p4
@show p5
nothing</code></pre>
<pre><code class="language-julia">p1 &#61; &#91;30, 40&#93;
p2 &#61; &#91;10, 20&#93;
p3 &#61; &#91;70, 80&#93;
p4 &#61; &#91;70, 80&#93;
p5 &#61; &#91;50, 60&#93;</code></pre>
<h2 id="condicional"><a href="#condicional" class="header-anchor">Condicional</a></h2>
<p>Temos, naturalmente, os fluxos condicionais de controle</p>
<pre><code class="language-julia">if condicional
    expr1
else
    expr2
end</code></pre>
<p>e</p>
<pre><code class="language-julia">if condicional1
    expr1
elseif condicional2
    expr2
...
else
    expr3
end</code></pre>
<p>Em pequenas expressões, pode ser conveniente escrever isso em uma única linha:</p>
<pre><code class="language-julia">if condicional expr1 else expr2 end</code></pre>
<h2 id="operador_ternário"><a href="#operador_ternário" class="header-anchor">Operador ternário</a></h2>
<p>O operador ternário</p>
<pre><code class="language-julia">condicional ? expr1 : expr2</code></pre>
<p>está relacionado com a condição <code>if else end</code> e é comumente utilizado em atribuições.</p>
<pre><code class="language-julia">test &#61; rand&#40;UInt8&#41;
resultado &#61; isodd&#40;test&#41; ? &quot;&#36;test é impar&quot; : &quot;&#36;test é par&quot;
test &#43;&#61; 1
@show resultado
resultado &#61; isodd&#40;test&#41; ? &quot;&#36;test é impar&quot; : &quot;&#36;test é par&quot;
@show resultado
nothing</code></pre>
<pre><code class="language-julia">resultado &#61; &quot;142 é par&quot;
resultado &#61; &quot;143 é impar&quot;</code></pre>
<h2 id="interpolação"><a href="#interpolação" class="header-anchor">Interpolação</a></h2>
<p>Observe que acima usamos o símbolo <code>&#36;</code> dentro de uma string. Ele é chamado de operador de <strong>interpolação</strong>. Ele substitui o valor da váriável na string.</p>
<p>Se quisermos escrever <code>&#36;</code> precisamos &quot;escapá-lo&quot; com uma barra invertida:</p>
<pre><code class="language-julia">valor &#61; 10.0
println&#40;&quot;Esse produto custa R\&#36;&#36;valor&quot;&#41;</code></pre>
<pre><code class="language-julia">Esse produto custa R&#36;10.0</code></pre>
<h2 id="escopo"><a href="#escopo" class="header-anchor">Escopo</a></h2>
<p>Várias construções envolvem tipos diferentes de escopo. Há três tipos de escopo: <strong>global</strong>, <strong>local flexível</strong> e <strong>local rígido</strong> &#40;numa tradução livre de <em>global</em>, <em>local &#40;soft&#41;</em> e <em>local &#40;hard&#41;</em>.&#41; Os escopos locais podem ser encadeados.</p>
<p>Veja o tipo de escopo de cada construção em <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/#man-scope-table">Scope constructs</a>.</p>
<p>Para entender em detalhes como cada escopo local funciona, veja <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Local-Scope">Local Scope</a>. Vamos ver alguns exemplos.</p>
<h3 id="escopo_em_loops"><a href="#escopo_em_loops" class="header-anchor">Escopo em loops</a></h3>
<p>Um exemplo que requer particular atenção é em loops <em>for</em> e <em>while</em>. O escopo é do tipo local flexível. Depende de uma variável estar ou não definida fora do loop.</p>
<pre><code class="language-julia">for i &#61; 1:2
    x &#61; &quot;iteração de número &#36;i&quot; # variável local
    println&#40;x&#41;
end</code></pre>
<pre><code class="language-julia">iteração de número 1
iteração de número 2</code></pre>
<pre><code class="language-julia">@isdefined&#40;x&#41;</code></pre>
<pre><code class="language-julia">false</code></pre>
<p>Como <code>x</code> só foi definido dentro do loop <code>for</code>, ela não persistiu no escopo global. Observe que esse comportamento é diferente do do python, onde não apenas <code>x</code> está definido como a variável auxiliar <code>i</code>, também. 🤷‍</p>
<pre><code class="language-julia">i &#61; 0
y &#61; &quot;iteração de número &#36;i&quot;
println&#40;y&#41;
for i &#61; 1:2
    y &#61; &quot;iteração de número &#36;i&quot; # variável local
    println&#40;y&#41;
end
println&#40;y&#41;</code></pre>
<pre><code class="language-julia">iteração de número 0
iteração de número 1
iteração de número 2
iteração de número 0</code></pre>
<p>Agora vemos que <code>y</code> foi atualizado dentro do loop.</p>
<p>Mais delicado é quando atribuímos uma variável global a uma nova variável local e a atualizamos</p>
<pre><code class="language-julia">z &#61; 0 # global
for i &#61; 1:10
    w &#61; z &#43; i # local
    z &#61; w # atualização global
end
@show z
@isdefined&#40;w&#41;</code></pre>
<pre><code class="language-julia">Error: UndefVarError: z not defined</code></pre>
<p>Se quisermos definir uma variável global dentro de um loop, podemos usar <code>global</code>:</p>
<pre><code class="language-julia">num &#61; 5
for i &#61; 1:num
    global u &#61; i &#61;&#61; 1 ? 1 : i*u
end
@show u</code></pre>
<pre><code class="language-julia">u &#61; 120
120</code></pre>
<p>O que representa <code>u</code> em relação a <code>num</code>?</p>
<h2 id="funções"><a href="#funções" class="header-anchor">Funções</a></h2>
<p>Assim como qualquer bloco, funções precisam ser terminadas com <code>end</code>. Além disso, o comando <code>return</code> é opcional para indicar o que será retornado pela função. Caso ele não seja usado, a última expressão executada é automaticamente retornada.</p>
<p>A recomendação, no entanto, é de que o comando <code>return</code> seja sempre usado, para maior clareza. A exceção é quando a função é definida em uma única linha de comando.</p>
<pre><code class="language-julia">f&#40;ζ&#41; &#61; 1 &#43; ζ^2 &#43; ζ^4 &#43; ζ^6

function g&#40;ζ&#41;
    η &#61; 1
    for i &#61; 2:2:6
        η &#43;&#61; ζ^i
    end
    return η
end

@show f&#40;2&#41;
@show g&#40;2&#41;
nothing</code></pre>
<pre><code class="language-julia">f&#40;2&#41; &#61; 85
g&#40;2&#41; &#61; 85</code></pre>
<h3 id="funções_com_variáveis_mutáveis_e_imutáveis"><a href="#funções_com_variáveis_mutáveis_e_imutáveis" class="header-anchor">Funções com variáveis mutáveis e imutáveis</a></h3>
<p>É preciso tomar cuidado ao alterarmos variáveis dentro de uma função.</p>
<p>Se alterarmos uma variável imutável, isso não afetará a variável original passada para a função. Mas se alteramos um elemeto mutável, isso a afetará.</p>
<p>Funções que afetam um ou mais argumentos são usualmente denotadas com o sufixo <code>&#33;</code>. Isso é apenas uma convenção. Esse símbolo não <em>faz</em> nada de especial.</p>
<pre><code class="language-julia">function h&#40;ρ&#41;
    ρ̄ &#61; copy&#40;ρ&#41;
    ρ &#61; 2 .*ρ
    return ρ &#43; ρ̄
end

function h&#33;&#40;ρ&#41;
    ρ̄ &#61; copy&#40;ρ&#41;
    ρ&#91;1:end&#93; &#61; 2 .*ρ&#91;1:end&#93;
    return ρ &#43; ρ̄
end

xx &#61; &#91;1,2&#93;
yy &#61; &#91;1,2&#93;

@show xx
@show h&#40;xx&#41;
@show xx
@show yy
@show h&#33;&#40;yy&#41;
@show yy
nothing</code></pre>
<pre><code class="language-julia">xx &#61; &#91;1, 2&#93;
h&#40;xx&#41; &#61; &#91;3, 6&#93;
xx &#61; &#91;1, 2&#93;
yy &#61; &#91;1, 2&#93;
h&#33;&#40;yy&#41; &#61; &#91;3, 6&#93;
yy &#61; &#91;2, 4&#93;</code></pre>
<h2 id="tipos_e_múltiplos_despachos"><a href="#tipos_e_múltiplos_despachos" class="header-anchor">Tipos e múltiplos despachos</a></h2>
<p>Julia não é uma linguagem orientada a objeto. Ela é fortemente baseada em <strong>tipos</strong> e em <strong>múltiplos despachos</strong> <em>&#40;ou multiple dispatch&#41;</em>. Isso é uma das coisas que a torna bastante poderosa. 🚀</p>
<p>Isso facilita bastante, por exemplo, o processo de estender funções e pacotes. Com ela, é fácil adaptar funções de um pacote de otimização &#40;e.g. <a href="https://fluxml.ai/Flux.jl/stable/">Flux.jl</a> para trabalhar com funções objetivo dependentes de soluções de equações diferenciais implementadas em outro pacote &#40;e.g. <a href="https://diffeq.sciml.ai/stable/">DifferentialEquations.jl</a> e assim por diante.</p>
<p>Em uma linguagem orientada a objeto, qualquer adaptação do gênero requer que todos os métodos sejam reescritos para novos objetos, sem contar com toda a verbose incluída.</p>
<p>Este não é um curso sobre Julia, então não vamos entrar em muitos detalhes, mas é importante saber sobre essa característica fundamental da linguagem. E gostaria de fazer um pequeno exemplo para exibir o poder disso.</p>
<h3 id="ordenando_listas"><a href="#ordenando_listas" class="header-anchor">Ordenando listas</a></h3>
<p>Podemos, naturalmente, ordenar uma lista de números. Isso pode ser feito com a função <code>sort</code>. Há vários métodos de ordenação implementados, mas não vamos nos preocupar com isso.</p>
<p>Podemos, também, ordenar pares ordenados e strings, em ordem lexicográfica.</p>
<pre><code class="language-julia">@show sort&#40;&#91;4,1,3&#93;&#41;
@show sort&#40;&#91;&quot;d&quot;, &quot;a&quot;, &quot;c&quot;&#93;&#41;
nothing</code></pre>
<pre><code class="language-julia">sort&#40;&#91;4, 1, 3&#93;&#41; &#61; &#91;1, 3, 4&#93;
sort&#40;&#91;&quot;d&quot;, &quot;a&quot;, &quot;c&quot;&#93;&#41; &#61; &#91;&quot;a&quot;, &quot;c&quot;, &quot;d&quot;&#93;</code></pre>
<h3 id="ordenando_retângulos"><a href="#ordenando_retângulos" class="header-anchor">Ordenando retângulos</a></h3>
<p>Digamos, agora, que queiramos definir um objeto &quot;retângulo&quot;, cujas propriedades são os tamanhos dos seus lados. Para isso, definimos um <em>struct</em> com essas propriedades:</p>
<pre><code class="language-julia">struct Retângulo
    lado1:: Float64
    lado2:: Float64
end

R1 &#61; Retângulo&#40;2,3&#41;
R2 &#61; Retângulo&#40;1.5, 6&#41;
R3 &#61; Retângulo&#40;1.2,7&#41;
R4 &#61; Retângulo&#40;3,2&#41;

R1, R2, R3, R4</code></pre>
<pre><code class="language-julia">&#40;Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;2.0, 3.0&#41;, Main.var&quot;##WeaveSandBox#
294&quot;.Retângulo&#40;1.5, 6.0&#41;, Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;1.2, 7.0&#41;,
 Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;3.0, 2.0&#41;&#41;</code></pre>
<p>Para qualquer retângulo, podemos definir a sua área. Podemos fazer isso definindo uma função atuando em dois argumentos <strong>do tipo Retângulo</strong>.</p>
<pre><code class="language-julia">area&#40;R::Retângulo&#41; &#61; R.lado1 * R.lado2

@show area&#40;R1&#41;
@show area&#40;R2&#41;
@show area&#40;R3&#41;
@show area&#40;R4&#41;</code></pre>
<pre><code class="language-julia">area&#40;R1&#41; &#61; 6.0
area&#40;R2&#41; &#61; 9.0
area&#40;R3&#41; &#61; 8.4
area&#40;R4&#41; &#61; 6.0
6.0</code></pre>
<p>Agora, pode ser interessante comparar os retângulos de acordo com as suas áreas. As funções binárias <code>&lt;, &#61;&#61;, &gt;</code> não estão definidas para retângulos. Mas podemos defini-las.</p>
<p>Um problema é que elas já existem para outros objetos. Assim, precisamos <strong>estender</strong> as definições para o nosso novo objeto. Isso precisa ser feito importando a função do módulo onde ela está definida.</p>
<p>Essas funções estão definidas no módulo Base. E na verdade só precisamos importar <code>isless</code> e <code>&#61;&#61;</code>, pois os outros operadores são definidos em função desses.</p>
<p>Podemos importar toda o módulo <code>Base</code>, mas isso é desnecessário. Vamos importar apenas o que precisamo estender.</p>
<p>Para estender, definimos não só o valor desejado da operação mas em que tipo ela se aplica.</p>
<pre><code class="language-julia">import Base: isless, &#61;&#61;

&#61;&#61;&#40;R::Retângulo, R̄::Retângulo&#41; &#61; area&#40;R&#41; &#61;&#61; area&#40;R̄&#41;
isless&#40;R::Retângulo, R̄::Retângulo&#41; &#61; area&#40;R&#41; &lt; area&#40;R̄&#41;

@show isless&#40;R1,R2&#41;
@show isless&#40;R1,R4&#41;
@show R1 &#61;&#61; R4</code></pre>
<pre><code class="language-julia">isless&#40;R1, R2&#41; &#61; true
isless&#40;R1, R4&#41; &#61; false
R1 &#61;&#61; R4 &#61; true
true</code></pre>
<p>Agora a primeira &quot;mágica&quot; aparece. Como dito acima, <code>&lt;</code> e <code>&gt;</code> são definidas a partir de <code>isless</code> e <code>&#61;&#61;</code>. Assim, essas operações são automaticamente estendidas.</p>
<pre><code class="language-julia">@show R1 &lt; R3
@show R1 &gt; R3
nothing</code></pre>
<pre><code class="language-julia">R1 &lt; R3 &#61; true
R1 &gt; R3 &#61; false</code></pre>
<p>Agora a segunda &quot;mágica&quot;. A função de ordenação <code>sort</code> também é definida a partir de <code>isless</code> e <code>&#61;&#61;</code> e está automaticamente estendida para os nosss retângulos.</p>
<pre><code class="language-julia">ordenados &#61; sort&#40;&#91;R1, R2, R3, R4&#93;&#41;
for &#40;i,R&#41; in enumerate&#40;ordenados&#41;
    println&#40;&quot;&#36;&#40;i&#41;ᵒ: &#36;R com área &#36;&#40;area&#40;R&#41;&#41;&quot;&#41;
end</code></pre>
<pre><code class="language-julia">1ᵒ: Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;2.0, 3.0&#41; com área 6.0
2ᵒ: Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;3.0, 2.0&#41; com área 6.0
3ᵒ: Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;1.2, 7.0&#41; com área 8.4
4ᵒ: Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;1.5, 6.0&#41; com área 9.0</code></pre>
<p>Da mesma forma, podemos imediatamente obter os valores máximo, mínimos e os respectivos retângulos:</p>
<pre><code class="language-julia">println&#40;&quot;Mínimo &#36;&#40;minimum&#40;&#91;R1, R2, R3, R4&#93;&#41;&#41; em &#36;&#40;argmin&#40;&#91;R1, R2, R3, R4&#93;&#41;&#41;&quot;&#41;</code></pre>
<pre><code class="language-julia">Mínimo Main.var&quot;##WeaveSandBox#294&quot;.Retângulo&#40;2.0, 3.0&#41; em 1</code></pre>
<h2 id="álgebra_linear"><a href="#álgebra_linear" class="header-anchor">Álgebra linear</a></h2>
<p>Várias ferramentas de álgebra linear estão diretamente disponíveis na <code>Base</code>. Outras no módulo <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a> da biblioteca padrão.</p>
<p>Na <code>Base</code>, podemos multiplicar matrizes &#40;composição&#41; e resolver um sistema &#40;<code>A\v</code> nos dá o vetor <code>u</code> tal que<code>Av &#61; u</code>, caso seja possível, ou resolve o problema de mínimos quadrados associado&#41;.</p>
<pre><code class="language-julia">vec &#61; &#91;1,2&#93;
mat &#61; &#91;1 3; 4 5&#93;
@show mat
@show mat&#39; # transposta
@show copy&#40;mat&#39;&#41; # transposta com tipo matriz
@show vec
@show mat * vec
@show mat \ vec
@show mat * &#40;mat \ vec&#41; - vec
nothing</code></pre>
<pre><code class="language-julia">mat &#61; &#91;1 3; 4 5&#93;
mat&#39; &#61; &#91;1 4; 3 5&#93;
copy&#40;mat&#39;&#41; &#61; &#91;1 4; 3 5&#93;
vec &#61; &#91;1, 2&#93;
mat * vec &#61; &#91;7, 14&#93;
mat \ vec &#61; &#91;0.14285714285714288, 0.2857142857142857&#93;
mat * &#40;mat \ vec&#41; - vec &#61; &#91;0.0, 0.0&#93;</code></pre>
<p>Algumas operações podem ser feitas tanto como matrizes, como \(A^2\) e \(e^A\), como elemento a elemento, com o operador ponto.</p>
<pre><code class="language-julia">@show mat^2
@show mat.^2
@show exp&#40;mat&#41;
@show exp.&#40;mat&#41;
nothing</code></pre>
<pre><code class="language-julia">mat ^ 2 &#61; &#91;13 18; 24 37&#93;
mat .^ 2 &#61; &#91;1 9; 16 25&#93;
exp&#40;mat&#41; &#61; &#91;274.43419918799526 411.0994796202357; 548.1326394936477 822.566
838681643&#93;
exp.&#40;mat&#41; &#61; &#91;2.718281828459045 20.085536923187668; 54.598150033144236 148.4
131591025766&#93;</code></pre>
<p>Outras operações importantes estão em <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a>.</p>
<p>O produto vetorial entre dois vetores, por exemplo, pode ser calculado de várias formas.</p>
<p>Uma opção e utilizando o operador ponto para somar elemento a elemento e em seguida somando-se os elementos do vetor resultante.</p>
<p>Outra é através das poderosas funções <code>map</code>, <code>reduce</code>, <code>mapreduce</code> e variantes.</p>
<p>Ou através do produto escalar disponível em <code>LinearAlgebra</code>. Este último tem a vantagem de ser bem mais rápido, como veremos em seguida.</p>
<pre><code class="language-julia">using LinearAlgebra

vec1 &#61; &#91;1.2, 3.1, -4.5, 2.1, -2.3, 10.1&#93;
vec2 &#61; &#91;0.3, -1.2, -5.2, -1.2, 20.1, 5.7&#93;
println&#40;sum&#40;vec1 .* vec2&#41;&#41;
println&#40;mapreduce&#40;elem -&gt; elem&#91;1&#93;*elem&#91;2&#93;, &#43;, zip&#40;vec1, vec2&#41;&#41;&#41;
println&#40;let p &#61; 0; for i in 1:length&#40;vec1&#41; p &#43;&#61; vec1&#91;i&#93;*vec2&#91;i&#93; end; p end&#41;
println&#40;vec1 ⋅ vec2&#41;
nothing</code></pre>
<pre><code class="language-julia">28.860000000000007
28.860000000000007
28.860000000000007
28.860000000000003</code></pre>
<p>O módulo <code>LinearAlgebra</code> nos dá diversas outras ferramentas, como cálculo de autovalores, autovetores normalizados, decomposição SVD, etc..</p>
<pre><code class="language-julia">eigen&#40;&#91;1 3; 4 5&#93;&#41;</code></pre>
<pre><code class="language-julia">LinearAlgebra.Eigen&#123;Float64, Float64, Matrix&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;
values:
2-element Vector&#123;Float64&#125;:
 -1.0
  7.0
vectors:
2×2 Matrix&#123;Float64&#125;:
 -0.83205  -0.447214
  0.5547   -0.894427</code></pre>
<pre><code class="language-julia">svd&#40;&#91;1 3; 4 5&#93;&#41;</code></pre>
<pre><code class="language-julia">LinearAlgebra.SVD&#123;Float64, Float64, Matrix&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;
U factor:
2×2 Matrix&#123;Float64&#125;:
 -0.428878  -0.903362
 -0.903362   0.428878
singular values:
2-element Vector&#123;Float64&#125;:
 7.072510139298386
 0.9897476090001657
Vt factor:
2×2 Matrix&#123;Float64&#125;:
 -0.571555  -0.820564
  0.820564  -0.571555</code></pre>
<h2 id="gráficos"><a href="#gráficos" class="header-anchor">Gráficos</a></h2>
<p>Há vários pacotes de gráficos.</p>
<p>Há muito o que ser explorado em termos de gráficos, mas, aqui, vamos nos limitar a exibir alguns poucos exemplos utilizando o <a href="http://docs.juliaplots.org/latest/">Plots.jl</a>.</p>
<pre><code class="language-julia">using Plots
gr&#40;&#41;
theme&#40;:ggplot2&#41;</code></pre>
<pre><code class="language-julia">I &#61; 0.0:0.1:2π
plot&#40;I, sin.&#40;I&#41;, xaxis&#61;&quot;x&quot;, yaxis&#61;&quot;y&quot;, label&#61;&quot;y&#61;sin&#40;x&#41;&quot;,
    title&#61;&quot;Gráfico de y&#61;sin&#40;x&#41; no intervalo &#40;0, 2π&#41;&quot;&#41;</code></pre>
<img src="/modelagem_matematica/assets/pages/jupytered/c01/0103-Primeiros_passos_Julia/code/images/0103-Primeiros_passos_Julia_29_1.png" alt="">
<pre><code class="language-julia">I &#61; 0.0:0.1:2π
plot&#40;I, &#91;sin.&#40;I&#41;, cos.&#40;I&#41;&#93;, xaxis&#61;&quot;x&quot;, yaxis&#61;&quot;y&quot;, label&#61;&#91;&quot;y&#61;sin&#40;x&#41;&quot; &quot;y&#61;cos&#40;x&#41;&quot;&#93;,
    title&#61;&quot;Gráficos de y&#61;sin&#40;x&#41; e y&#61;cos&#40;x&#41; no intervalo &#40;0, 2π&#41;&quot;&#41;</code></pre>
<img src="/modelagem_matematica/assets/pages/jupytered/c01/0103-Primeiros_passos_Julia/code/images/0103-Primeiros_passos_Julia_30_1.png" alt="">
<pre><code class="language-julia">plot&#40;area.&#40;ordenados&#41;, xaxis&#61;&quot;ordem&quot;, yaxis&#61;&quot;área&quot;, label&#61;&quot;área&quot;, color&#61;:brown3,
    marker &#61; :circle, markersize &#61; 8, linewidth &#61; 4, 
    title&#61;&quot;Área dos retângulos em ordem crescente&quot;, titlefontsize&#61;12,
    legend&#61;:topleft, ylims&#61;&#40;0.0, 10.0&#41;
&#41;</code></pre>
<img src="/modelagem_matematica/assets/pages/jupytered/c01/0103-Primeiros_passos_Julia/code/images/0103-Primeiros_passos_Julia_31_1.png" alt="">
<h2 id="performance"><a href="#performance" class="header-anchor">Performance</a></h2>
<p>A macro <code>@time</code> nos dá alguma informação sobre o tempo de execução, número de alocações e memória utilizada na execução de alguma linha ou bloco de código.</p>
<pre><code class="language-julia">@time length&#40;&quot;Modelagem Matemática&quot;^1000&#41;
@time begin
    s &#61; &quot;Modelagem Matemática&quot;
    s ^&#61; 1000
    length&#40;s&#41;
end
nothing</code></pre>
<pre><code class="language-julia">0.000017 seconds &#40;1 allocation: 20.625 KiB&#41;
  0.000637 seconds &#40;25 allocations: 21.906 KiB, 95.23&#37; compilation time&#41;</code></pre>
<p>O pacote <a href="https://github.com/JuliaCI/BenchmarkTools.jl">JuliaCI/BenchmarkTools.jl</a> é mais completo e dá mais informações para avaliar a performance dos códigos.</p>
<p>Em particular, ela executa o código várias vezes, para evitar ruído e retornar uma informação mais precisa sobre a performance.</p>
<p>Por exemplo, podemos comparar as diversas maneiras de se calcular o produto escalar entre dois vetores.</p>
<pre><code class="language-julia">using BenchmarkTools

vec1 &#61; rand&#40;100&#41;
vec2 &#61; rand&#40;100&#41;

escalar1&#40;vec1, vec2&#41; &#61; sum&#40;vec1 .* vec2&#41;
escalar2&#40;vec1, vec2&#41; &#61; mapreduce&#40;elem -&gt; elem&#91;1&#93;*elem&#91;2&#93;, &#43;, zip&#40;vec1, vec2&#41;&#41;
escalar3&#40;vec1, vec2&#41; &#61; let p &#61; 0; for i in 1:length&#40;vec1&#41; p &#43;&#61; vec1&#91;i&#93;*vec2&#91;i&#93; end; p end
escalar4&#40;vec1, vec2&#41; &#61; vec1 ⋅ vec2

@show escalar1&#40;vec1, vec2&#41; ≈ escalar2&#40;vec1, vec2&#41; ≈ escalar3&#40;vec1, vec2&#41; ≈ escalar4&#40;vec1, vec2&#41;

@btime escalar1&#40;&#36;vec1, &#36;vec2&#41;
@btime escalar2&#40;&#36;vec1, &#36;vec2&#41;
@btime escalar3&#40;&#36;vec1, &#36;vec2&#41;
@btime escalar4&#40;&#36;vec1, &#36;vec2&#41;
nothing</code></pre>
<pre><code class="language-julia">escalar1&#40;vec1, vec2&#41; ≈ escalar2&#40;vec1, vec2&#41; ≈ escalar3&#40;vec1, vec2&#41; ≈ escala
r4&#40;vec1, vec2&#41; &#61; true
  72.125 ns &#40;1 allocation: 896 bytes&#41;
  61.396 ns &#40;0 allocations: 0 bytes&#41;
  443.182 ns &#40;0 allocations: 0 bytes&#41;
  35.114 ns &#40;0 allocations: 0 bytes&#41;</code></pre>
<p>Para uma estatística mais detalhada, usamos <code>@benchmark</code>.</p>
<pre><code class="language-julia">@benchmark escalar4&#40;v, w&#41; setup &#61; &#40;v&#61;&#36;vec1; w&#61;&#36;vec2&#41;</code></pre>
<pre><code class="language-julia">BenchmarkTools.Trial: 10000 samples with 992 evaluations.
 Range &#40;min … max&#41;:  37.719 ns … 211.021 ns  ┊ GC &#40;min … max&#41;: 0.00&#37; … 0.00
&#37;
 Time  &#40;median&#41;:     37.886 ns               ┊ GC &#40;median&#41;:    0.00&#37;
 Time  &#40;mean ± σ&#41;:   38.730 ns ±   4.385 ns  ┊ GC &#40;mean ± σ&#41;:  0.00&#37; ± 0.00
&#37;

  █▂▁▂▄▁  ▁▁▁                                                  ▁
  ███████████▆▆▅▅▅▅▅▄▄▄▃▄▅▅▄▃▄▄▅▄▃▄▅▄▃▄▄▃▆▄▃▄▅▃▂▃▄▄▅▄▂▄▃▄▅▃▄▄▄ █
  37.7 ns       Histogram: log&#40;frequency&#41; by time      56.1 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre>

    <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c01/0102-Instalando_acessando_Julia">1.2. Instalando e acessando o Julia <kbd>←</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c02/0201-Principios_basicos"><kbd>→</kbd> 2.1. Princípios básicos de modelagem</a>
</span>
    </p>
</div>
</br></br>



<div class="page-foot">
    
        <div class="license">
            <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/>(CC BY-NC-ND 4.0) Attribution-NonCommercial-NoDerivatives 4.0 International </a>
            
        </div>
    

    Last modified: March 09, 2022. Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
</div><!-- CONTENT ENDS HERE -->

      </div> <!-- .books-content -->
    </div> <!-- .books-container -->

    
        <script src="/modelagem_matematica/libs/katex/katex.min.js"></script>
        <script src="/modelagem_matematica/libs/katex/auto-render.min.js"></script>
        <script>renderMathInElement(document.body)</script>
    

    
        <script src="/modelagem_matematica/libs/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>
    

  </body>
</html>
