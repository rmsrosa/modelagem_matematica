<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" xml:lang="en-US">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="" />
  <meta name="author" content="and contributors" />
   <title>Primeiros passos em Julia</title>  
  <link rel="shortcut icon" type="image/png" href="/modelagem_matematica/assets/images/favicon.png"/>
  <link rel="stylesheet" href="/modelagem_matematica/css/base.css"/>
  
    <link rel="stylesheet" href="/modelagem_matematica/css/base_showaside.css"/>
  
  <script src="/modelagem_matematica/libs/mousetrap/mousetrap.min.js"></script>

  
    <link rel="stylesheet" href="/modelagem_matematica/libs/highlight/github.min.css">
    <script src="/modelagem_matematica/libs/highlight/highlight.pack.js"></script>
    <script src="/modelagem_matematica/libs/highlight/julia.min.js"></script>
    <script>
      document.addEventListener('DOMContentLoaded', (event) => {
        document.querySelectorAll('pre').forEach((el) => {
          hljs.highlightElement(el);
        });
      });
    </script>
  

  
    <link rel="stylesheet" href="/modelagem_matematica/libs/katex/katex.min.css">
  
</head>

<body>

  <div class="books-container">

  <aside class="books-menu">
  <input type="checkbox" id="menu">
  <label for="menu">‚ò∞</label>

  <div class="books-title">
    <a href="/modelagem_matematica/">Modelagem Matem√°tica</a>
  </div>

  <br />

  <div class="books-subtitle">
    Notas de aula
  </div>

  <br />

  <div class="books-author">
    <a href="https://rmsrosa.github.io">Ricardo M. S. Rosa</a>
  </div>

  <div class="books-menu-content">
    <div class="menu-level-1">
    <li><a href="/modelagem_matematica/pages/intro">Introdu√ß√£o</a></li>
    </div>
    <div class="menu-level-1">
    <li>PARTE I</li>
    </div>
    <div class="menu-level-1">
    <li>1. Preliminares</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c01/0101-Aspectos_curso">1.1. Aspectos do curso</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c01/0102-Instalando_acessando_Julia">1.2. Instalando e acessando o Julia</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c01/0103-Primeiros_passos_Julia">1.3. Primeiros passos em Julia</a></li>
    </div>
    <div class="menu-level-1">
    <li>PARTE II</li>
    </div>
    <div class="menu-level-1">
    <li>2. Princ√≠pios de Modelagem Matem√°tica</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c02/0201-Principios_basicos">2.1. Princ√≠pios b√°sicos de modelagem</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c02/0202-Exemplos_tipos_modelagem">2.2. Exemplos de tipos de modelagem</a></li>
    </div>
    <div class="menu-level-1">
    <li>3. An√°lise Dimensional</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c03/0301-Quantidades_unidades_dimensoes">3.1. Quantidades, unidades e dimens√µes</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c03/0302-BuckinghamPi">3.2. An√°lise dimensional e o Teorema de Buckingham-Pi</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c03/0303-Unidades_Julia">3.3. Trabalhando com unidades e dimens√µes em Julia</a></li>
    </div>
    <div class="menu-level-1">
    <li>4. Ajuste de Par√¢metros</li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0401-Minimos_quadrados_ajuste">4.1. M√≠nimos quadrados e o ajuste de par√¢metros</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0402-Modelos_redutiveis_linear_aplicacoes">4.2. Modelos redut√≠veis ao caso linear nos par√¢metros e aplica√ß√µes</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0403-Minimos_quadrados_nao_linear">4.3. M√≠nimos quadrados n√£o-linear</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0404-Exemplos_ajuste_naolinear">4.4. Exemplos de ajuste n√£o-linear de par√¢metros</a></li>
    </div>
    <div class="menu-level-2">
    <li><a href="/modelagem_matematica/pages/jupytered/c04/0405-Ajuste_em_redes_neurais">4.5. Ajuste de par√¢metros em modelos de redes neurais (WIP)</a></li>
    </div>
<div>


  
    <a href="https://github.com/rmsrosa/modelagem_matematica/tree/modmat2022p1"><img src="/modelagem_matematica/assets/images/GitHub-Mark-32px.png" alt="GitHub repo" width="18" style="margin:5px 5px" align="left"></a>

  

</aside>


  <div class="books-content">

    
      <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c01/0102-Instalando_acessando_Julia">1.2. Instalando e acessando o Julia <kbd>‚Üê</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c02/0201-Principios_basicos"><kbd>‚Üí</kbd> 2.1. Princ√≠pios b√°sicos de modelagem</a>
</span>
    </p>
</div>
</br></br>

    

    
      <div class="badges">
<p>
<a href="https://nbviewer.org/urls/rmsrosa.github.io/modelagem_matematica/tree/modmat2021p1/generated/notebooks/jupytered/c01/0103-Primeiros_passos_Julia.ipynb"><img align="left" src="https://img.shields.io/badge/view%20in-nbviewer-orange" alt="View in NBViewer" title="View Jupyter notebook in NBViewer"></a>
<a href="https://mybinder.org/v2/gh/rmsrosa/modelagem_matematica/julia-env-for-binder-2022p1?urlpath=git-pull%3Frepo%3Dhttps://github.com/rmsrosa/modelagem_matematica/tree/modmat2022p1%26urlpath%3Dlab/tree%252Fmodelagem_matematica/generated/notebooks/jupytered/c01/0103-Primeiros_passos_Julia.ipynb%26branch%3Dgh-pages"><img align="left" src="https://mybinder.org/badge.svg" alt="Open in binder" title="Open in binder"></a>
<a href="/modelagem_matematica/generated/notebooks/jupytered/c01/0103-Primeiros_passos_Julia.ipynb"><img align="left" src="https://img.shields.io/badge/download-notebook-blue" alt="Download notebook" title="Download Jupyter notebook"></a>
<a href="https://github.com/rmsrosa/modelagem_matematica/tree/modmat2022p1/blob/main/_src/jupyter/c01/0103-Primeiros_passos_Julia.ipynb"><img align="left" src="https://img.shields.io/badge/view-source-lightblue" alt="View source" title="View source"></a>
</p>
</div></br>

    
<h1 id="get_title"><a href="#get_title" class="header-anchor">1.3. Primeiros passos em Julia</a></h1>
<p>H√° v√°rias fontes de informa√ß√£o sobre a linguagem Julia. Vejam, por exemplo, os links informados no in√≠cio do caderno anterior. Em particular,</p>
<ul>
<li><p>Guias r√°pidos</p>
<ul>
<li><p><a href="https://docs.julialang.org/en/v1/">Julia Documentation</a></p>
</li>
<li><p><a href="https://julia.quantecon.org/getting_started_julia/index.html">Getting Started with Julia &#40;QuantEcon&#41;</a></p>
</li>
<li><p><a href="https://juliadocs.github.io/Julia-Cheat-Sheet/br/">A via r√°pida para Julia 1.0</a></p>
</li>
<li><p><a href="https://cheatsheets.quantecon.org">MATLAB‚ÄìPython‚ÄìJulia cheatsheet &#40;QuantEcon&#41;</a></p>
</li>
<li><p><a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/">Noteworthy Differences from other Languages</a></p>
</li>
</ul>
</li>
<li><p>Mais detalhados</p>
<ul>
<li><p><a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html">Think Julia: How to Think Like a Computer Scientist</a></p>
</li>
<li><p><a href="https://en.wikibooks.org/wiki/Introducing_Julia">Introducing Julia</a></p>
</li>
<li><p><a href="http://ucidatascienceinitiative.github.io/IntroToJulia/">A Deep Introduction to Julia for Data Science and Scientific Computing</a></p>
</li>
</ul>
</li>
</ul>
<p>N√£o pretendo reinventar a roda, aqui. Sugiro que vejam pelo menos uns dois links dos mencionados. Em particular, <a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#Mathematical-Operations-and-Elementary-Functions">Mathematical Operations and Elementary Functions</a>, da documenta√ß√£o. A documenta√ß√£o do Julia √© muito boa&#33;</p>
<p>Se voc√™ est√° acostumado com python, por exemplo, veja <a href="https://docs.julialang.org/en/v1/manual/noteworthy-differences/#Noteworthy-differences-from-Python">Noteworthy differences from Python</a>.</p>
<p>Vou apenas fazer alguns coment√°rios que considero relevantes.</p>
<h2 id="blocos_de_c√≥digo"><a href="#blocos_de_c√≥digo" class="header-anchor">Blocos de c√≥digo</a></h2>
<p>Identar o c√≥digo √© extramemente recomendado, mas, contrariamente ao python, n√£o √© obrigat√≥rio. Por isso, √© necess√°rio concluir os blocos com <code>end</code>.</p>
<p>A vantagem disso √© que √© f√°cil copiar um c√≥digo e rodar em outro ambiente, como no REPL, por exemplo, sem se preocupar com o processo de copiar e colar modificar a identa√ß√£o.</p>
<pre><code class="language-julia">for i &#61; 1:5
    println&#40;i&#41;
end</code></pre>
<pre><code class="language-julia">1
2
3
4
5</code></pre>
<h2 id="caracteres_unicode"><a href="#caracteres_unicode" class="header-anchor">Caracteres unicode</a></h2>
<p>Caracteres unicode podem, e costumam ser, usados como vari√°veis. Voc√™ pode obt√™-los, <em>em c√©lulas de c√≥digo</em>, digitando o s√≠mbolo deles seguido de <code>&lt;tab&gt;</code>. V√°rios nomes s√£o derivados da denomina√ß√£o deles em latex. Por exemplo, para obter \(\pi\) acima, basta digitar <code>\pi&lt;tab&gt;</code>.</p>
<p>Para uma lista completa dos caracteres unicodes obtidos completando com <code>&lt;tab&gt;</code>, veja <a href="https://docs.julialang.org/en/v1/manual/unicode-input/">Unicode Input</a>.</p>
<p>Subescritos e superescritos podem ser obtidos com <code>^\&#96; e</code>_&#96;, seguidos de <code>&lt;tab&gt;</code>. Por exemplo \(x_1\) √© obtido com <code>x\_1&lt;tab&gt;</code>.</p>
<p>Outros &quot;adere√ßos&quot; tambem podem ser obtidos com <code>&lt;tab&gt;</code>, por exemplo, \(\bar x\) √© obtido com <code>x\bar&lt;tab&gt;</code> e \(\tilde x\), com <code>x\tilde&lt;bar&gt;</code>.</p>
<p>Aproveitando a quest√£o da nota√ß√£o, a multiplica√ß√£o entre um n√∫mero e um s√≠mbolo <em>n√£o precisa</em> usar o s√≠mbolo de multiplica√ß√£o <code>*</code>.</p>
<p>Exemplos:</p>
<pre><code class="language-julia">œµ &#61; 0.01
Œæ &#61; 0:0.01:2œÄ
Œ∑ &#61; sin.&#40;Œæ&#41;
ŒæÃÑ &#61; Œæ&#91;argmax&#40;Œ∑&#41;&#93;
println&#40;&quot;M√°ximo de Œæ ‚Ü¶ sin&#40;Œæ&#41; em ŒæÃÑ &#61; &#36;ŒæÃÑ.&quot;&#41;
error &#61; abs&#40;ŒæÃÑ - œÄ/2&#41; &lt; œµ ? &quot;Dentro da margem de erro œµ &#61; &#36;œµ em rela√ß√£o ao valor esperado œÄ/2.&quot; :
    &quot;Fora da margem de error œµ &#61; &#36;œµ em rela√ß√£o ao valor esperado œÄ/2.&quot;
println&#40;error&#41;</code></pre>
<pre><code class="language-julia">M√°ximo de Œæ ‚Ü¶ sin&#40;Œæ&#41; em ŒæÃÑ &#61; 1.57.
Dentro da margem de erro œµ &#61; 0.01 em rela√ß√£o ao valor esperado œÄ/2.</code></pre>
<h2 id="broadcasting_e_o_operador_ponto"><a href="#broadcasting_e_o_operador_ponto" class="header-anchor">Broadcasting e o &quot;operador ponto&quot;</a></h2>
<p>O operador ponto aplica uma opera√ß√£o a cada elemento de um vetor ou matriz ou adiciona um escalar a cada componente de um vetor. O operador ponto est√° diretamente ligado ao operador de <em>broadcasting</em>. Veja mais sobre isso em <em>&#40;<a href="https://docs.julialang.org/en/v1/manual/mathematical-operations/#man-dot-operators">dot operators</a>&#41;</em> e <em><a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasting</a></em>. Por aqui, fiquemos com os seguintes exemplos.</p>
<pre><code class="language-julia">@show 2^2
@show &#91;1,2,3&#93;.^2
@show &#91;1 2; 3 4&#93;.^2
@show sin.&#40;&#91;0, œÄ/4, œÄ/2, œÄ&#93;&#41;
@show 1 .&#43; &#91;1,2,3,4&#93;
nothing</code></pre>
<pre><code class="language-julia">2 ^ 2 &#61; 4
&#91;1, 2, 3&#93; .^ 2 &#61; &#91;1, 4, 9&#93;
&#91;1 2; 3 4&#93; .^ 2 &#61; &#91;1 4; 9 16&#93;
sin.&#40;&#91;0, œÄ / 4, œÄ / 2, œÄ&#93;&#41; &#61; &#91;0.0, 0.7071067811865475, 1.0, 1.2246467991473
532e-16&#93;
1 .&#43; &#91;1, 2, 3, 4&#93; &#61; &#91;2, 3, 4, 5&#93;</code></pre>
<h2 id="atribui√ß√£o_e_vari√°veis_mut√°veis_e_imut√°veis"><a href="#atribui√ß√£o_e_vari√°veis_mut√°veis_e_imut√°veis" class="header-anchor">Atribui√ß√£o e vari√°veis mut√°veis e imut√°veis</a></h2>
<p>Alguns objetos s√£o mut√°veis, enquanto que outros, n√£o. Um objeto mut√°vel pode ter os seus valores alterados. J√° um objeto imut√°vel, n√£o, mas ele pode ser redefinido.</p>
<p>Isso pode ser visto explicitamente pelo seu ponteiro &#40;pelo menos em alguns casos&#41;.</p>
<h3 id="atribui√ß√£o_de_vetores"><a href="#atribui√ß√£o_de_vetores" class="header-anchor">Atribui√ß√£o de vetores</a></h3>
<p>Por exemplo. Um vetor √© imut√°vel, mas os seu valores, n√£o. Se mudarmos apenas o valor de um ou mais de seus elementos, ele continua apontando para o mesmo local na mem√≥ria. J√° se o redefinirmos, ele pode passar a apontar para outro lugar. Isso √© visivelmente natural se pensarmos que, nesse processo, podemos acabar alterando o tamanho do vetor e, com isso, pode ser necess√°rio mud√°-lo de posi√ß√£o para que ele caiba na mem√≥ria.</p>
<p>Essa mudan√ßa no apontamento quando redefinimos uma variavel imut√°vel pode ou n√£o acontecer. Ela n√£o √© obrigat√≥ria. Mas ela nunca √© alterada quando o valor, mut√°vel, de uma vari√°vel √© alterado.</p>
<pre><code class="language-julia">a &#61; &#91;0, 1&#93; # defini√ß√£o inicial de &#96;a&#96;
@show pointer&#40;a&#41;
a &#61; &#91;2, 3&#93; # redefinindo &#96;a&#96; para um vetor de mesmo comprimento
@show pointer&#40;a&#41;
a &#61; &#91;4, 5, 6&#93; # redefindo &#96;a&#96; para um vetor de comprimento diferente
@show pointer&#40;a&#41;
a&#91;1&#93; &#61; 7 # modificando um elemento de &#96;a&#96;
@show pointer&#40;a&#41;
a&#91;1:3&#93; &#61; &#91;8,9,0&#93; # modificando todos os elementos de &#96;a&#96;
@show pointer&#40;a&#41;
nothing</code></pre>
<pre><code class="language-julia">pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162ac1530
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b77e20
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b78bd0
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b78bd0
pointer&#40;a&#41; &#61; Ptr&#123;Int64&#125; @0x0000000162b78bd0</code></pre>
<h3 id="atribui√ß√£o_de_strings"><a href="#atribui√ß√£o_de_strings" class="header-anchor">Atribui√ß√£o de strings</a></h3>
<p><em>Strings</em> tamb√©m s√£o imut√°veis.</p>
<pre><code class="language-julia">s &#61; &quot;Equa√ß√µes diferenciais&quot;
@show pointer&#40;s&#41;
s &#61; &quot;Modelagem Matem√°tica&quot;
@show pointer&#40;s&#41;
s &#61; replace&#40;s, &quot;Modelagem&quot; &#61;&gt; &quot;Modelos&quot;&#41;&#91;1:end-1&#93;*&quot;os&quot;
@show pointer&#40;s&#41;
@show s
nothing</code></pre>
<pre><code class="language-julia">pointer&#40;s&#41; &#61; Ptr&#123;UInt8&#125; @0x000000010a254a68
pointer&#40;s&#41; &#61; Ptr&#123;UInt8&#125; @0x000000010a254ab8
pointer&#40;s&#41; &#61; Ptr&#123;UInt8&#125; @0x000000010a254cc0
s &#61; &quot;Modelos Matem√°ticos&quot;</code></pre>
<h3 id="cuidados_com_a_atribui√ß√£o_de_vari√°veis_imut√°veis"><a href="#cuidados_com_a_atribui√ß√£o_de_vari√°veis_imut√°veis" class="header-anchor">Cuidados com a atribui√ß√£o de vari√°veis imut√°veis</a></h3>
<p>No caso de um objeto imut√°vel mas com elementos mut√°veis &#40;e.g. <em>arrays</em>, <em>dicts</em>, <em>sets</em>&#41;, √© preciso termos cuidado quando tentamos copi√°-lo.</p>
<p>A atribui√ß√£o pura e simples n√£o acarreta em uma c√≥pia, ela faz com que o novo objeto fa√ßa refer√™ncia ao mesmo objeto. Assim, se modificarmos os valores mut√°veis do objeto original, o novo objeto sofrer√° as mesmas mudan√ßas.</p>
<p>No exemplo abaixo, observe que a redefini√ß√£o da vari√°vel imut√°vel <code>p1</code> n√£o afetou <code>p2</code>, mas a mudan√ßa nos valores mut√°veis de <code>p3</code> afetou <code>p4</code>.</p>
<p>Para evitar isso, √© preciso usar <code>copy</code>. Nesse caso, vemos que <code>p5</code> n√£o sofreu altera√ß√£o.</p>
<pre><code class="language-julia">p1 &#61; &#91;10,20&#93;
p2 &#61; p1
p1 &#61; &#91;30,40&#93;
@show p1
@show p2
p3 &#61; &#91;50,60&#93;
p4 &#61; p3
p5 &#61; copy&#40;p3&#41;
p3&#91;1:2&#93; &#61; &#91;70,80&#93;
@show p3
@show p4
@show p5
nothing</code></pre>
<pre><code class="language-julia">p1 &#61; &#91;30, 40&#93;
p2 &#61; &#91;10, 20&#93;
p3 &#61; &#91;70, 80&#93;
p4 &#61; &#91;70, 80&#93;
p5 &#61; &#91;50, 60&#93;</code></pre>
<h2 id="condicional"><a href="#condicional" class="header-anchor">Condicional</a></h2>
<p>Temos, naturalmente, os fluxos condicionais de controle</p>
<pre><code class="language-julia">if condicional
    expr1
else
    expr2
end</code></pre>
<p>e</p>
<pre><code class="language-julia">if condicional1
    expr1
elseif condicional2
    expr2
...
else
    expr3
end</code></pre>
<p>Em pequenas express√µes, pode ser conveniente escrever isso em uma √∫nica linha:</p>
<pre><code class="language-julia">if condicional expr1 else expr2 end</code></pre>
<h2 id="operador_tern√°rio"><a href="#operador_tern√°rio" class="header-anchor">Operador tern√°rio</a></h2>
<p>O operador tern√°rio</p>
<pre><code class="language-julia">condicional ? expr1 : expr2</code></pre>
<p>est√° relacionado com a condi√ß√£o <code>if else end</code> e √© comumente utilizado em atribui√ß√µes.</p>
<pre><code class="language-julia">test &#61; rand&#40;UInt8&#41;
resultado &#61; isodd&#40;test&#41; ? &quot;&#36;test √© impar&quot; : &quot;&#36;test √© par&quot;
test &#43;&#61; 1
@show resultado
resultado &#61; isodd&#40;test&#41; ? &quot;&#36;test √© impar&quot; : &quot;&#36;test √© par&quot;
@show resultado
nothing</code></pre>
<pre><code class="language-julia">resultado &#61; &quot;142 √© par&quot;
resultado &#61; &quot;143 √© impar&quot;</code></pre>
<h2 id="interpola√ß√£o"><a href="#interpola√ß√£o" class="header-anchor">Interpola√ß√£o</a></h2>
<p>Observe que acima usamos o s√≠mbolo <code>&#36;</code> dentro de uma string. Ele √© chamado de operador de <strong>interpola√ß√£o</strong>. Ele substitui o valor da v√°ri√°vel na string.</p>
<p>Se quisermos escrever <code>&#36;</code> precisamos &quot;escap√°-lo&quot; com uma barra invertida:</p>
<pre><code class="language-julia">valor &#61; 10.0
println&#40;&quot;Esse produto custa R\&#36;&#36;valor&quot;&#41;</code></pre>
<pre><code class="language-julia">Esse produto custa R&#36;10.0</code></pre>
<h2 id="escopo"><a href="#escopo" class="header-anchor">Escopo</a></h2>
<p>V√°rias constru√ß√µes envolvem tipos diferentes de escopo. H√° tr√™s tipos de escopo: <strong>global</strong>, <strong>local flex√≠vel</strong> e <strong>local r√≠gido</strong> &#40;numa tradu√ß√£o livre de <em>global</em>, <em>local &#40;soft&#41;</em> e <em>local &#40;hard&#41;</em>.&#41; Os escopos locais podem ser encadeados.</p>
<p>Veja o tipo de escopo de cada constru√ß√£o em <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/#man-scope-table">Scope constructs</a>.</p>
<p>Para entender em detalhes como cada escopo local funciona, veja <a href="https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Local-Scope">Local Scope</a>. Vamos ver alguns exemplos.</p>
<h3 id="escopo_em_loops"><a href="#escopo_em_loops" class="header-anchor">Escopo em loops</a></h3>
<p>Um exemplo que requer particular aten√ß√£o √© em loops <em>for</em> e <em>while</em>. O escopo √© do tipo local flex√≠vel. Depende de uma vari√°vel estar ou n√£o definida fora do loop.</p>
<pre><code class="language-julia">for i &#61; 1:2
    x &#61; &quot;itera√ß√£o de n√∫mero &#36;i&quot; # vari√°vel local
    println&#40;x&#41;
end</code></pre>
<pre><code class="language-julia">itera√ß√£o de n√∫mero 1
itera√ß√£o de n√∫mero 2</code></pre>
<pre><code class="language-julia">@isdefined&#40;x&#41;</code></pre>
<pre><code class="language-julia">false</code></pre>
<p>Como <code>x</code> s√≥ foi definido dentro do loop <code>for</code>, ela n√£o persistiu no escopo global. Observe que esse comportamento √© diferente do do python, onde n√£o apenas <code>x</code> est√° definido como a vari√°vel auxiliar <code>i</code>, tamb√©m. ü§∑‚Äç</p>
<pre><code class="language-julia">i &#61; 0
y &#61; &quot;itera√ß√£o de n√∫mero &#36;i&quot;
println&#40;y&#41;
for i &#61; 1:2
    y &#61; &quot;itera√ß√£o de n√∫mero &#36;i&quot; # vari√°vel local
    println&#40;y&#41;
end
println&#40;y&#41;</code></pre>
<pre><code class="language-julia">itera√ß√£o de n√∫mero 0
itera√ß√£o de n√∫mero 1
itera√ß√£o de n√∫mero 2
itera√ß√£o de n√∫mero 0</code></pre>
<p>Agora vemos que <code>y</code> foi atualizado dentro do loop.</p>
<p>Mais delicado √© quando atribu√≠mos uma vari√°vel global a uma nova vari√°vel local e a atualizamos</p>
<pre><code class="language-julia">z &#61; 0 # global
for i &#61; 1:10
    w &#61; z &#43; i # local
    z &#61; w # atualiza√ß√£o global
end
@show z
@isdefined&#40;w&#41;</code></pre>
<pre><code class="language-julia">Error: UndefVarError: z not defined</code></pre>
<p>Se quisermos definir uma vari√°vel global dentro de um loop, podemos usar <code>global</code>:</p>
<pre><code class="language-julia">num &#61; 5
for i &#61; 1:num
    global u &#61; i &#61;&#61; 1 ? 1 : i*u
end
@show u</code></pre>
<pre><code class="language-julia">u &#61; 120
120</code></pre>
<p>O que representa <code>u</code> em rela√ß√£o a <code>num</code>?</p>
<h2 id="fun√ß√µes"><a href="#fun√ß√µes" class="header-anchor">Fun√ß√µes</a></h2>
<p>Assim como qualquer bloco, fun√ß√µes precisam ser terminadas com <code>end</code>. Al√©m disso, o comando <code>return</code> √© opcional para indicar o que ser√° retornado pela fun√ß√£o. Caso ele n√£o seja usado, a √∫ltima express√£o executada √© automaticamente retornada.</p>
<p>A recomenda√ß√£o, no entanto, √© de que o comando <code>return</code> seja sempre usado, para maior clareza. A exce√ß√£o √© quando a fun√ß√£o √© definida em uma √∫nica linha de comando.</p>
<pre><code class="language-julia">f&#40;Œ∂&#41; &#61; 1 &#43; Œ∂^2 &#43; Œ∂^4 &#43; Œ∂^6

function g&#40;Œ∂&#41;
    Œ∑ &#61; 1
    for i &#61; 2:2:6
        Œ∑ &#43;&#61; Œ∂^i
    end
    return Œ∑
end

@show f&#40;2&#41;
@show g&#40;2&#41;
nothing</code></pre>
<pre><code class="language-julia">f&#40;2&#41; &#61; 85
g&#40;2&#41; &#61; 85</code></pre>
<h3 id="fun√ß√µes_com_vari√°veis_mut√°veis_e_imut√°veis"><a href="#fun√ß√µes_com_vari√°veis_mut√°veis_e_imut√°veis" class="header-anchor">Fun√ß√µes com vari√°veis mut√°veis e imut√°veis</a></h3>
<p>√â preciso tomar cuidado ao alterarmos vari√°veis dentro de uma fun√ß√£o.</p>
<p>Se alterarmos uma vari√°vel imut√°vel, isso n√£o afetar√° a vari√°vel original passada para a fun√ß√£o. Mas se alteramos um elemeto mut√°vel, isso a afetar√°.</p>
<p>Fun√ß√µes que afetam um ou mais argumentos s√£o usualmente denotadas com o sufixo <code>&#33;</code>. Isso √© apenas uma conven√ß√£o. Esse s√≠mbolo n√£o <em>faz</em> nada de especial.</p>
<pre><code class="language-julia">function h&#40;œÅ&#41;
    œÅÃÑ &#61; copy&#40;œÅ&#41;
    œÅ &#61; 2 .*œÅ
    return œÅ &#43; œÅÃÑ
end

function h&#33;&#40;œÅ&#41;
    œÅÃÑ &#61; copy&#40;œÅ&#41;
    œÅ&#91;1:end&#93; &#61; 2 .*œÅ&#91;1:end&#93;
    return œÅ &#43; œÅÃÑ
end

xx &#61; &#91;1,2&#93;
yy &#61; &#91;1,2&#93;

@show xx
@show h&#40;xx&#41;
@show xx
@show yy
@show h&#33;&#40;yy&#41;
@show yy
nothing</code></pre>
<pre><code class="language-julia">xx &#61; &#91;1, 2&#93;
h&#40;xx&#41; &#61; &#91;3, 6&#93;
xx &#61; &#91;1, 2&#93;
yy &#61; &#91;1, 2&#93;
h&#33;&#40;yy&#41; &#61; &#91;3, 6&#93;
yy &#61; &#91;2, 4&#93;</code></pre>
<h2 id="tipos_e_m√∫ltiplos_despachos"><a href="#tipos_e_m√∫ltiplos_despachos" class="header-anchor">Tipos e m√∫ltiplos despachos</a></h2>
<p>Julia n√£o √© uma linguagem orientada a objeto. Ela √© fortemente baseada em <strong>tipos</strong> e em <strong>m√∫ltiplos despachos</strong> <em>&#40;ou multiple dispatch&#41;</em>. Isso √© uma das coisas que a torna bastante poderosa. üöÄ</p>
<p>Isso facilita bastante, por exemplo, o processo de estender fun√ß√µes e pacotes. Com ela, √© f√°cil adaptar fun√ß√µes de um pacote de otimiza√ß√£o &#40;e.g. <a href="https://fluxml.ai/Flux.jl/stable/">Flux.jl</a> para trabalhar com fun√ß√µes objetivo dependentes de solu√ß√µes de equa√ß√µes diferenciais implementadas em outro pacote &#40;e.g. <a href="https://diffeq.sciml.ai/stable/">DifferentialEquations.jl</a> e assim por diante.</p>
<p>Em uma linguagem orientada a objeto, qualquer adapta√ß√£o do g√™nero requer que todos os m√©todos sejam reescritos para novos objetos, sem contar com toda a verbose inclu√≠da.</p>
<p>Este n√£o √© um curso sobre Julia, ent√£o n√£o vamos entrar em muitos detalhes, mas √© importante saber sobre essa caracter√≠stica fundamental da linguagem. E gostaria de fazer um pequeno exemplo para exibir o poder disso.</p>
<h3 id="ordenando_listas"><a href="#ordenando_listas" class="header-anchor">Ordenando listas</a></h3>
<p>Podemos, naturalmente, ordenar uma lista de n√∫meros. Isso pode ser feito com a fun√ß√£o <code>sort</code>. H√° v√°rios m√©todos de ordena√ß√£o implementados, mas n√£o vamos nos preocupar com isso.</p>
<p>Podemos, tamb√©m, ordenar pares ordenados e strings, em ordem lexicogr√°fica.</p>
<pre><code class="language-julia">@show sort&#40;&#91;4,1,3&#93;&#41;
@show sort&#40;&#91;&quot;d&quot;, &quot;a&quot;, &quot;c&quot;&#93;&#41;
nothing</code></pre>
<pre><code class="language-julia">sort&#40;&#91;4, 1, 3&#93;&#41; &#61; &#91;1, 3, 4&#93;
sort&#40;&#91;&quot;d&quot;, &quot;a&quot;, &quot;c&quot;&#93;&#41; &#61; &#91;&quot;a&quot;, &quot;c&quot;, &quot;d&quot;&#93;</code></pre>
<h3 id="ordenando_ret√¢ngulos"><a href="#ordenando_ret√¢ngulos" class="header-anchor">Ordenando ret√¢ngulos</a></h3>
<p>Digamos, agora, que queiramos definir um objeto &quot;ret√¢ngulo&quot;, cujas propriedades s√£o os tamanhos dos seus lados. Para isso, definimos um <em>struct</em> com essas propriedades:</p>
<pre><code class="language-julia">struct Ret√¢ngulo
    lado1:: Float64
    lado2:: Float64
end

R1 &#61; Ret√¢ngulo&#40;2,3&#41;
R2 &#61; Ret√¢ngulo&#40;1.5, 6&#41;
R3 &#61; Ret√¢ngulo&#40;1.2,7&#41;
R4 &#61; Ret√¢ngulo&#40;3,2&#41;

R1, R2, R3, R4</code></pre>
<pre><code class="language-julia">&#40;Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;2.0, 3.0&#41;, Main.var&quot;##WeaveSandBox#
294&quot;.Ret√¢ngulo&#40;1.5, 6.0&#41;, Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;1.2, 7.0&#41;,
 Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;3.0, 2.0&#41;&#41;</code></pre>
<p>Para qualquer ret√¢ngulo, podemos definir a sua √°rea. Podemos fazer isso definindo uma fun√ß√£o atuando em dois argumentos <strong>do tipo Ret√¢ngulo</strong>.</p>
<pre><code class="language-julia">area&#40;R::Ret√¢ngulo&#41; &#61; R.lado1 * R.lado2

@show area&#40;R1&#41;
@show area&#40;R2&#41;
@show area&#40;R3&#41;
@show area&#40;R4&#41;</code></pre>
<pre><code class="language-julia">area&#40;R1&#41; &#61; 6.0
area&#40;R2&#41; &#61; 9.0
area&#40;R3&#41; &#61; 8.4
area&#40;R4&#41; &#61; 6.0
6.0</code></pre>
<p>Agora, pode ser interessante comparar os ret√¢ngulos de acordo com as suas √°reas. As fun√ß√µes bin√°rias <code>&lt;, &#61;&#61;, &gt;</code> n√£o est√£o definidas para ret√¢ngulos. Mas podemos defini-las.</p>
<p>Um problema √© que elas j√° existem para outros objetos. Assim, precisamos <strong>estender</strong> as defini√ß√µes para o nosso novo objeto. Isso precisa ser feito importando a fun√ß√£o do m√≥dulo onde ela est√° definida.</p>
<p>Essas fun√ß√µes est√£o definidas no m√≥dulo Base. E na verdade s√≥ precisamos importar <code>isless</code> e <code>&#61;&#61;</code>, pois os outros operadores s√£o definidos em fun√ß√£o desses.</p>
<p>Podemos importar toda o m√≥dulo <code>Base</code>, mas isso √© desnecess√°rio. Vamos importar apenas o que precisamo estender.</p>
<p>Para estender, definimos n√£o s√≥ o valor desejado da opera√ß√£o mas em que tipo ela se aplica.</p>
<pre><code class="language-julia">import Base: isless, &#61;&#61;

&#61;&#61;&#40;R::Ret√¢ngulo, RÃÑ::Ret√¢ngulo&#41; &#61; area&#40;R&#41; &#61;&#61; area&#40;RÃÑ&#41;
isless&#40;R::Ret√¢ngulo, RÃÑ::Ret√¢ngulo&#41; &#61; area&#40;R&#41; &lt; area&#40;RÃÑ&#41;

@show isless&#40;R1,R2&#41;
@show isless&#40;R1,R4&#41;
@show R1 &#61;&#61; R4</code></pre>
<pre><code class="language-julia">isless&#40;R1, R2&#41; &#61; true
isless&#40;R1, R4&#41; &#61; false
R1 &#61;&#61; R4 &#61; true
true</code></pre>
<p>Agora a primeira &quot;m√°gica&quot; aparece. Como dito acima, <code>&lt;</code> e <code>&gt;</code> s√£o definidas a partir de <code>isless</code> e <code>&#61;&#61;</code>. Assim, essas opera√ß√µes s√£o automaticamente estendidas.</p>
<pre><code class="language-julia">@show R1 &lt; R3
@show R1 &gt; R3
nothing</code></pre>
<pre><code class="language-julia">R1 &lt; R3 &#61; true
R1 &gt; R3 &#61; false</code></pre>
<p>Agora a segunda &quot;m√°gica&quot;. A fun√ß√£o de ordena√ß√£o <code>sort</code> tamb√©m √© definida a partir de <code>isless</code> e <code>&#61;&#61;</code> e est√° automaticamente estendida para os nosss ret√¢ngulos.</p>
<pre><code class="language-julia">ordenados &#61; sort&#40;&#91;R1, R2, R3, R4&#93;&#41;
for &#40;i,R&#41; in enumerate&#40;ordenados&#41;
    println&#40;&quot;&#36;&#40;i&#41;·µí: &#36;R com √°rea &#36;&#40;area&#40;R&#41;&#41;&quot;&#41;
end</code></pre>
<pre><code class="language-julia">1·µí: Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;2.0, 3.0&#41; com √°rea 6.0
2·µí: Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;3.0, 2.0&#41; com √°rea 6.0
3·µí: Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;1.2, 7.0&#41; com √°rea 8.4
4·µí: Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;1.5, 6.0&#41; com √°rea 9.0</code></pre>
<p>Da mesma forma, podemos imediatamente obter os valores m√°ximo, m√≠nimos e os respectivos ret√¢ngulos:</p>
<pre><code class="language-julia">println&#40;&quot;M√≠nimo &#36;&#40;minimum&#40;&#91;R1, R2, R3, R4&#93;&#41;&#41; em &#36;&#40;argmin&#40;&#91;R1, R2, R3, R4&#93;&#41;&#41;&quot;&#41;</code></pre>
<pre><code class="language-julia">M√≠nimo Main.var&quot;##WeaveSandBox#294&quot;.Ret√¢ngulo&#40;2.0, 3.0&#41; em 1</code></pre>
<h2 id="√°lgebra_linear"><a href="#√°lgebra_linear" class="header-anchor">√Ålgebra linear</a></h2>
<p>V√°rias ferramentas de √°lgebra linear est√£o diretamente dispon√≠veis na <code>Base</code>. Outras no m√≥dulo <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a> da biblioteca padr√£o.</p>
<p>Na <code>Base</code>, podemos multiplicar matrizes &#40;composi√ß√£o&#41; e resolver um sistema &#40;<code>A\v</code> nos d√° o vetor <code>u</code> tal que<code>Av &#61; u</code>, caso seja poss√≠vel, ou resolve o problema de m√≠nimos quadrados associado&#41;.</p>
<pre><code class="language-julia">vec &#61; &#91;1,2&#93;
mat &#61; &#91;1 3; 4 5&#93;
@show mat
@show mat&#39; # transposta
@show copy&#40;mat&#39;&#41; # transposta com tipo matriz
@show vec
@show mat * vec
@show mat \ vec
@show mat * &#40;mat \ vec&#41; - vec
nothing</code></pre>
<pre><code class="language-julia">mat &#61; &#91;1 3; 4 5&#93;
mat&#39; &#61; &#91;1 4; 3 5&#93;
copy&#40;mat&#39;&#41; &#61; &#91;1 4; 3 5&#93;
vec &#61; &#91;1, 2&#93;
mat * vec &#61; &#91;7, 14&#93;
mat \ vec &#61; &#91;0.14285714285714288, 0.2857142857142857&#93;
mat * &#40;mat \ vec&#41; - vec &#61; &#91;0.0, 0.0&#93;</code></pre>
<p>Algumas opera√ß√µes podem ser feitas tanto como matrizes, como \(A^2\) e \(e^A\), como elemento a elemento, com o operador ponto.</p>
<pre><code class="language-julia">@show mat^2
@show mat.^2
@show exp&#40;mat&#41;
@show exp.&#40;mat&#41;
nothing</code></pre>
<pre><code class="language-julia">mat ^ 2 &#61; &#91;13 18; 24 37&#93;
mat .^ 2 &#61; &#91;1 9; 16 25&#93;
exp&#40;mat&#41; &#61; &#91;274.43419918799526 411.0994796202357; 548.1326394936477 822.566
838681643&#93;
exp.&#40;mat&#41; &#61; &#91;2.718281828459045 20.085536923187668; 54.598150033144236 148.4
131591025766&#93;</code></pre>
<p>Outras opera√ß√µes importantes est√£o em <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">LinearAlgebra</a>.</p>
<p>O produto vetorial entre dois vetores, por exemplo, pode ser calculado de v√°rias formas.</p>
<p>Uma op√ß√£o e utilizando o operador ponto para somar elemento a elemento e em seguida somando-se os elementos do vetor resultante.</p>
<p>Outra √© atrav√©s das poderosas fun√ß√µes <code>map</code>, <code>reduce</code>, <code>mapreduce</code> e variantes.</p>
<p>Ou atrav√©s do produto escalar dispon√≠vel em <code>LinearAlgebra</code>. Este √∫ltimo tem a vantagem de ser bem mais r√°pido, como veremos em seguida.</p>
<pre><code class="language-julia">using LinearAlgebra

vec1 &#61; &#91;1.2, 3.1, -4.5, 2.1, -2.3, 10.1&#93;
vec2 &#61; &#91;0.3, -1.2, -5.2, -1.2, 20.1, 5.7&#93;
println&#40;sum&#40;vec1 .* vec2&#41;&#41;
println&#40;mapreduce&#40;elem -&gt; elem&#91;1&#93;*elem&#91;2&#93;, &#43;, zip&#40;vec1, vec2&#41;&#41;&#41;
println&#40;let p &#61; 0; for i in 1:length&#40;vec1&#41; p &#43;&#61; vec1&#91;i&#93;*vec2&#91;i&#93; end; p end&#41;
println&#40;vec1 ‚ãÖ vec2&#41;
nothing</code></pre>
<pre><code class="language-julia">28.860000000000007
28.860000000000007
28.860000000000007
28.860000000000003</code></pre>
<p>O m√≥dulo <code>LinearAlgebra</code> nos d√° diversas outras ferramentas, como c√°lculo de autovalores, autovetores normalizados, decomposi√ß√£o SVD, etc..</p>
<pre><code class="language-julia">eigen&#40;&#91;1 3; 4 5&#93;&#41;</code></pre>
<pre><code class="language-julia">LinearAlgebra.Eigen&#123;Float64, Float64, Matrix&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;
values:
2-element Vector&#123;Float64&#125;:
 -1.0
  7.0
vectors:
2√ó2 Matrix&#123;Float64&#125;:
 -0.83205  -0.447214
  0.5547   -0.894427</code></pre>
<pre><code class="language-julia">svd&#40;&#91;1 3; 4 5&#93;&#41;</code></pre>
<pre><code class="language-julia">LinearAlgebra.SVD&#123;Float64, Float64, Matrix&#123;Float64&#125;, Vector&#123;Float64&#125;&#125;
U factor:
2√ó2 Matrix&#123;Float64&#125;:
 -0.428878  -0.903362
 -0.903362   0.428878
singular values:
2-element Vector&#123;Float64&#125;:
 7.072510139298386
 0.9897476090001657
Vt factor:
2√ó2 Matrix&#123;Float64&#125;:
 -0.571555  -0.820564
  0.820564  -0.571555</code></pre>
<h2 id="gr√°ficos"><a href="#gr√°ficos" class="header-anchor">Gr√°ficos</a></h2>
<p>H√° v√°rios pacotes de gr√°ficos.</p>
<p>H√° muito o que ser explorado em termos de gr√°ficos, mas, aqui, vamos nos limitar a exibir alguns poucos exemplos utilizando o <a href="http://docs.juliaplots.org/latest/">Plots.jl</a>.</p>
<pre><code class="language-julia">using Plots
gr&#40;&#41;
theme&#40;:ggplot2&#41;</code></pre>
<pre><code class="language-julia">I &#61; 0.0:0.1:2œÄ
plot&#40;I, sin.&#40;I&#41;, xaxis&#61;&quot;x&quot;, yaxis&#61;&quot;y&quot;, label&#61;&quot;y&#61;sin&#40;x&#41;&quot;,
    title&#61;&quot;Gr√°fico de y&#61;sin&#40;x&#41; no intervalo &#40;0, 2œÄ&#41;&quot;&#41;</code></pre>
<img src="/modelagem_matematica/assets/pages/jupytered/c01/0103-Primeiros_passos_Julia/code/images/0103-Primeiros_passos_Julia_29_1.png" alt="">
<pre><code class="language-julia">I &#61; 0.0:0.1:2œÄ
plot&#40;I, &#91;sin.&#40;I&#41;, cos.&#40;I&#41;&#93;, xaxis&#61;&quot;x&quot;, yaxis&#61;&quot;y&quot;, label&#61;&#91;&quot;y&#61;sin&#40;x&#41;&quot; &quot;y&#61;cos&#40;x&#41;&quot;&#93;,
    title&#61;&quot;Gr√°ficos de y&#61;sin&#40;x&#41; e y&#61;cos&#40;x&#41; no intervalo &#40;0, 2œÄ&#41;&quot;&#41;</code></pre>
<img src="/modelagem_matematica/assets/pages/jupytered/c01/0103-Primeiros_passos_Julia/code/images/0103-Primeiros_passos_Julia_30_1.png" alt="">
<pre><code class="language-julia">plot&#40;area.&#40;ordenados&#41;, xaxis&#61;&quot;ordem&quot;, yaxis&#61;&quot;√°rea&quot;, label&#61;&quot;√°rea&quot;, color&#61;:brown3,
    marker &#61; :circle, markersize &#61; 8, linewidth &#61; 4, 
    title&#61;&quot;√Årea dos ret√¢ngulos em ordem crescente&quot;, titlefontsize&#61;12,
    legend&#61;:topleft, ylims&#61;&#40;0.0, 10.0&#41;
&#41;</code></pre>
<img src="/modelagem_matematica/assets/pages/jupytered/c01/0103-Primeiros_passos_Julia/code/images/0103-Primeiros_passos_Julia_31_1.png" alt="">
<h2 id="performance"><a href="#performance" class="header-anchor">Performance</a></h2>
<p>A macro <code>@time</code> nos d√° alguma informa√ß√£o sobre o tempo de execu√ß√£o, n√∫mero de aloca√ß√µes e mem√≥ria utilizada na execu√ß√£o de alguma linha ou bloco de c√≥digo.</p>
<pre><code class="language-julia">@time length&#40;&quot;Modelagem Matem√°tica&quot;^1000&#41;
@time begin
    s &#61; &quot;Modelagem Matem√°tica&quot;
    s ^&#61; 1000
    length&#40;s&#41;
end
nothing</code></pre>
<pre><code class="language-julia">0.000017 seconds &#40;1 allocation: 20.625 KiB&#41;
  0.000637 seconds &#40;25 allocations: 21.906 KiB, 95.23&#37; compilation time&#41;</code></pre>
<p>O pacote <a href="https://github.com/JuliaCI/BenchmarkTools.jl">JuliaCI/BenchmarkTools.jl</a> √© mais completo e d√° mais informa√ß√µes para avaliar a performance dos c√≥digos.</p>
<p>Em particular, ela executa o c√≥digo v√°rias vezes, para evitar ru√≠do e retornar uma informa√ß√£o mais precisa sobre a performance.</p>
<p>Por exemplo, podemos comparar as diversas maneiras de se calcular o produto escalar entre dois vetores.</p>
<pre><code class="language-julia">using BenchmarkTools

vec1 &#61; rand&#40;100&#41;
vec2 &#61; rand&#40;100&#41;

escalar1&#40;vec1, vec2&#41; &#61; sum&#40;vec1 .* vec2&#41;
escalar2&#40;vec1, vec2&#41; &#61; mapreduce&#40;elem -&gt; elem&#91;1&#93;*elem&#91;2&#93;, &#43;, zip&#40;vec1, vec2&#41;&#41;
escalar3&#40;vec1, vec2&#41; &#61; let p &#61; 0; for i in 1:length&#40;vec1&#41; p &#43;&#61; vec1&#91;i&#93;*vec2&#91;i&#93; end; p end
escalar4&#40;vec1, vec2&#41; &#61; vec1 ‚ãÖ vec2

@show escalar1&#40;vec1, vec2&#41; ‚âà escalar2&#40;vec1, vec2&#41; ‚âà escalar3&#40;vec1, vec2&#41; ‚âà escalar4&#40;vec1, vec2&#41;

@btime escalar1&#40;&#36;vec1, &#36;vec2&#41;
@btime escalar2&#40;&#36;vec1, &#36;vec2&#41;
@btime escalar3&#40;&#36;vec1, &#36;vec2&#41;
@btime escalar4&#40;&#36;vec1, &#36;vec2&#41;
nothing</code></pre>
<pre><code class="language-julia">escalar1&#40;vec1, vec2&#41; ‚âà escalar2&#40;vec1, vec2&#41; ‚âà escalar3&#40;vec1, vec2&#41; ‚âà escala
r4&#40;vec1, vec2&#41; &#61; true
  72.125 ns &#40;1 allocation: 896 bytes&#41;
  61.396 ns &#40;0 allocations: 0 bytes&#41;
  443.182 ns &#40;0 allocations: 0 bytes&#41;
  35.114 ns &#40;0 allocations: 0 bytes&#41;</code></pre>
<p>Para uma estat√≠stica mais detalhada, usamos <code>@benchmark</code>.</p>
<pre><code class="language-julia">@benchmark escalar4&#40;v, w&#41; setup &#61; &#40;v&#61;&#36;vec1; w&#61;&#36;vec2&#41;</code></pre>
<pre><code class="language-julia">BenchmarkTools.Trial: 10000 samples with 992 evaluations.
 Range &#40;min ‚Ä¶ max&#41;:  37.719 ns ‚Ä¶ 211.021 ns  ‚îä GC &#40;min ‚Ä¶ max&#41;: 0.00&#37; ‚Ä¶ 0.00
&#37;
 Time  &#40;median&#41;:     37.886 ns               ‚îä GC &#40;median&#41;:    0.00&#37;
 Time  &#40;mean ¬± œÉ&#41;:   38.730 ns ¬±   4.385 ns  ‚îä GC &#40;mean ¬± œÉ&#41;:  0.00&#37; ¬± 0.00
&#37;

  ‚ñà‚ñÇ‚ñÅ‚ñÇ‚ñÑ‚ñÅ  ‚ñÅ‚ñÅ‚ñÅ                                                  ‚ñÅ
  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñÜ‚ñÜ‚ñÖ‚ñÖ‚ñÖ‚ñÖ‚ñÖ‚ñÑ‚ñÑ‚ñÑ‚ñÉ‚ñÑ‚ñÖ‚ñÖ‚ñÑ‚ñÉ‚ñÑ‚ñÑ‚ñÖ‚ñÑ‚ñÉ‚ñÑ‚ñÖ‚ñÑ‚ñÉ‚ñÑ‚ñÑ‚ñÉ‚ñÜ‚ñÑ‚ñÉ‚ñÑ‚ñÖ‚ñÉ‚ñÇ‚ñÉ‚ñÑ‚ñÑ‚ñÖ‚ñÑ‚ñÇ‚ñÑ‚ñÉ‚ñÑ‚ñÖ‚ñÉ‚ñÑ‚ñÑ‚ñÑ ‚ñà
  37.7 ns       Histogram: log&#40;frequency&#41; by time      56.1 ns &lt;

 Memory estimate: 0 bytes, allocs estimate: 0.</code></pre>

    <div class="navbar">
    <p id="nav">
<span id="nav-prev" style="float: left;">
<a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c01/0102-Instalando_acessando_Julia">1.2. Instalando e acessando o Julia <kbd>‚Üê</kbd></a>
</span>
<span id="nav-next" style="float: right;">
    <a class="menu-level-1" href="/modelagem_matematica/pages/jupytered/c02/0201-Principios_basicos"><kbd>‚Üí</kbd> 2.1. Princ√≠pios b√°sicos de modelagem</a>
</span>
    </p>
</div>
</br></br>



<div class="page-foot">
    
        <div class="license">
            <a href=https://creativecommons.org/licenses/by-nc-nd/4.0/>(CC BY-NC-ND 4.0) Attribution-NonCommercial-NoDerivatives 4.0 International </a>
            
        </div>
    

    Last modified: March 09, 2022. Built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
</div><!-- CONTENT ENDS HERE -->

      </div> <!-- .books-content -->
    </div> <!-- .books-container -->

    
        <script src="/modelagem_matematica/libs/katex/katex.min.js"></script>
        <script src="/modelagem_matematica/libs/katex/auto-render.min.js"></script>
        <script>renderMathInElement(document.body)</script>
    

    
        <script src="/modelagem_matematica/libs/highlight/highlight.pack.js"></script>
        <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>
    

  </body>
</html>
